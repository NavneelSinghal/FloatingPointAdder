# Testing 

We divide testing into two major chunks - randomized testing and tailored testing.

1. **Randomized test cases** (used 6 million random test cases, and added a built-in verifier in the main code to check correctness)

2. **Tailored test cases** -
    For the development of each test case, we keep the following 4-tuple of data in mind:
        
        (type of operand 1, type of operand 2, type of result, number of normalisations)
    
    We also test for the rounding direction correctness in subsequent test cases (show that we do not round away from 0 or towards 0 or towards +inf or towards -inf, but use the correct default rounding used by IEEE 754 standards
    
    We also see corner cases for overflow (exact overflow, underflow, effect of rounding on overflow/underflow). Here exact means that the result is just sufficient to cause overflow/underflow.
    
    Different types of floating point numbers - 
        
        a. normal (we only call positive or negative floating point numbers normal, zero is treated as a special case)
        
        b. denormal
        
        c. 0
        
        d. inf
        
        e. -inf
        
        f. nan

In the tailored test cases, we implement two types of testing:

1. **Quick testing** - preliminary tests used and found during development of the adder to ensure the correctness.

2. **Systematic testing** - exhaustive tests used in the testing and debugging phase

## Quick testing

1. a + (-a)

    01000001100001100000000000000000
    
    11000001100001100000000000000000

2. 0 + 0
    
    00000000000000000000000000000000
    
    00000000000000000000000000000000

3. random

    01010010101001010100101010100101
    
    01010101001010101010100010101010

4. inf + -inf = nan

    01111111100000000000000000000000
    
    11111111100000000000000000000000

5. 0 + number

    00000000000000000000000000000000
    
    00000101010101001001000001101001

6. rounding test case (needs to be normalised again after the rounding)

    01000000000000000000000000000000
    
    00111111111111111111111111111111

7. random

    00111111111111111111111111111111

    10110101111010100000001001010000

8. random

    10110101111010100000001001010000
    
    10111001001010100000000101011110

9. denormal + normal number

    00000000000110101111101111001001

    00000001000000001010001101011011

10. normal + normal gives denormal results

    00000000100000000000000000000100
    
    10000000100000000000000000000011

11. another test case where the result needs to be normalised after the rounding

    00000001001010101010101010101010
    
    00000000101010101010101010101011

## Systematic exhaustive testing

1. denormal + denormal = denormal

    +, +

    00000000000110100010100100100101
    
    00000000010100100101001001010010

    +, -

    00000000000110100010100100100101
    
    10000000010100100101001001010010

    -, +

    10000000000110100010100100100101
    
    00000000010100100101001001010010

    -, -

    10000000000110100010100100100101
    
    10000000010100100101001001010010

2. denormal + denormal = normal

    +, +

    00000000010000000000000000000001
    
    00000000010000000000000000000000

    -, -

    10000000010000000000000000000001
    
    10000000010000000000000000000000

3. denormal + denormal = 0

    +, -

    00000000010100100100101010101001
    
    10000000010100100100101010101001

4. denormal + normal = denormal

    +, -

    00000000010101010101010101010101

    10000000100000000000000000000000

    -, +

    10000000010101010101010101010101
    
    00000000100000000000000000000000

5. denormal + normal = normal

    +, +
    
    00000000011010010001010100101010
    
    00000000111101010010100010100010

    +, -

    00000000011010010001010100101010
    
    10000000111101010010100010100010

    -, +

    10000000011010010001010100101010
    
    00000000111101010010100010100010

    -, -

    10000000011010010001010100101010
    
    10000000111101010010100010100010

6. normal + normal = denormal

    +, -

    00000010000000010010011100001000
    
    10000010000000010010011100001001

    -, +

    10000010000000010010011100001000
    
    00000010000000010010011100001001

7. normal + normal = normal

    This was done in the random testing, as most test cases are of this form

8. normal + normal = 0

    +, -

    00100100010100100101010010001010

    10100100010100100101010010001010

    -, +

    10100100010100100101010010001010
    
    00100100010100100101010010001010

9. normal + normal = inf

    +, +

    01111111001111111111111111111111
    
    01111110100000000000000000001001

10. normal + normal = -inf

    -, -

    11111111001111111111111111111111
    
    11111110100000000000000000001001

11. inf + denormal = inf

    +, +

    01111111100000000000000000000000
    
    00000000010100100100101010101001

    +, -

    01111111100000000000000000000000
    
    00000000010100100100101010101001

12. inf + normal = inf

    +, +

    01111111100000000000000000000000
    
    00101001001010100111001001001000

    +, -

    01111111100000000000000000000000
    
    10101001001010100111001001001000

13. inf + inf = inf

    01111111100000000000000000000000

    01111111100000000000000000000000

14. inf + -inf = nan

    01111111100000000000000000000000
    
    11111111100000000000000000000000

15. -inf + denormal = -inf

    -, +

    11111111100000000000000000000000

    00000000010100100100101010101001

    -, -

    11111111100000000000000000000000

    10000000010100100100101010101001

16. -inf + normal = -inf

    -, +

    11111111100000000000000000000000

    00101001001010100111001001001000

    -, -

    11111111100000000000000000000000
    
    10101001001010100111001001001000

17. -inf + -inf = -inf

    11111111100000000000000000000000

    11111111100000000000000000000000

18. 0 + denormal = denormal

    0, +

    00000000000000000000000000000000
    
    00000000000000000011010100000101

    0, -

    00000000000000000000000000000000
    
    10000000000000000011010100000101

19. 0 + inf = inf

    00000000000000000000000000000000
    
    01111111100000000000000000000000

20. 0 + normal = normal

    0, +

    00000000000000000000000000000000

    01010100010010010010000010010011

    0, -

    00000000000000000000000000000000

    11010100010010010010000010010011

21. 0 + -inf = -inf

    00000000000000000000000000000000

    11111111100000000000000000000000

22. 0 + 0 = 0

    00000000000000000000000000000000
    
    00000000000000000000000000000000

23. nan + normal = nan

    nan, +

    01111111110100101111000000000000
    
    01101001010010010100010010011010

    nan, -

    01111111110100101111000000000000
    
    11101001010010010100010010011010

24. nan + denormal = nan

    nan, +

    01111111101001001000000000000011

    00000000000000001101001001000001

    nan, -

    01111111101001001000000000000011
    
    00000000000000001101001001000001

25. nan + 0 = nan
    
    01111111101001001000000000000011
    
    00000000000000000000000000000000

26. nan + nan = nan

    01111111101001001000000000000011
    
    01111111101001001000000000000011

27. nan + inf = nan

    01111111101001001000000000000011

    01111111100000000000000000000000

28. nan + -inf = nan

    01111111101001001000000000000011
    
    11111111100000000000000000000000

29. Exact overflow

    01111111010000000000000000000000

    01111110100000000000000000000000

30. Exact underflow

    00000000111111111111111111111111

    10000000100000000000000000000000

    00000001000000000000000000000000
    
    10000000100000000000000000000001

31. Exact overflow after rounding

    01111111010000000000000000000000
    
    01111110011111111111111111111111

32. Exact non-overflow

    01111111010000000000000000000000
    
    01111110011111111111111111111100

32. Non-underflow corner case due to rounding

    00000001000000000000000000000001
    
    10000000100000000000000000000001

33. Rounding test case for direction of rounding

    00000001010000000000000000000001

    10000000100000000000000000000001

34. Rounding test cases (based on the guard, round and sticky bits)

    01000000011000000000000000011111
    
    01000001011100000000000000001001

    01000000011000000000000000011111
    
    11000001011100000000000000001001

    11000000011000000000000000011111
    
    01000001011100000000000000001001

    11000000011000000000000000011111
    
    11000001011100000000000000001001

    01000000011000000000000000011111

    01000001011100000000000000001001

    01000000011000000000000000011111

    11000001011100000000000000001001

    11000000011000000000000000011111
    
    01000001011100000000000000001001

    11000000011000000000000000011111
    
    11000001011100000000000000001001
